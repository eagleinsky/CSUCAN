C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 1   


C166 COMPILER V7.53.0.0, COMPILATION OF MODULE PDO
OBJECT MODULE PLACED IN .\obj\pdo.obj
COMPILER INVOKED BY: C:\Keil4\C166\BIN\C166.EXE CANopen\src\pdo.c MODV2 BROWSE INCDIR(.\source;.\CANopen\include;.\CANop
                    -en\include\XC164_CANopen;..\keil4;.\CANopen\examples\XC164\Slave) MODV2 DEBUG PRINT(.\list\pdo.lst) TABS(2) OBJECT(.\obj
                    -\pdo.obj) 

 stmt lvl     source

    1         /*
    2           This file is part of CanFestival, a library implementing CanOpen
    3           Stack.
    4         
    5           Copyright (C): Edouard TISSERANT and Francis DUPIN
    6         
    7           See COPYING file for copyrights details.
    8         
    9           This library is free software; you can redistribute it and/or
   10           modify it under the terms of the GNU Lesser General Public
   11           License as published by the Free Software Foundation; either
   12           version 2.1 of the License, or (at your option) any later version.
   13         
   14           This library is distributed in the hope that it will be useful,
   15           but WITHOUT ANY WARRANTY; without even the implied warranty of
   16           MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   17           Lesser General Public License for more details.
   18         
   19           You should have received a copy of the GNU Lesser General Public
   20           License along with this library; if not, write to the Free Software
   21           Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
   22           USA
   23         */
   24         #include "pdo.h"
   25         #include "objacces.h"
   26         #include "canfestival.h"
   27         #include "sysdep.h"
   28         
   29         /*!
   30         ** @file   pdo.c
   31         ** @author Edouard TISSERANT and Francis DUPIN
   32         ** @date   Tue Jun  5 09:32:32 2007
   33         **
   34         ** @brief
   35         **
   36         **
   37         */
   38         
   39         /*!
   40         **
   41         **
   42         ** @param d
   43         ** @param TPDO_com TPDO communication parameters OD entry
   44         ** @param TPDO_map TPDO mapping parameters OD entry
   45         **
   46         ** @return
   47         **/
   48         
   49         UNS8 buildPDO (CO_Data * d, UNS8 numPdo, Message * pdo)
   50         {
   51  1        const indextable *TPDO_com = d->objdict + d->firstIndex->PDO_TRS + numPdo;
   52  1        const indextable *TPDO_map = d->objdict + d->firstIndex->PDO_TRS_MAP + numPdo;
   53  1      
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 2   

   54  1        UNS8 prp_j = 0x00;
   55  1        UNS32 offset = 0x00000000;
   56  1        const UNS8 *pMappingCount = (UNS8 *) TPDO_map->pSubindex[0].pObject;
   57  1      
   58  1        pdo->cob_id = (UNS16) UNS16_LE(*(UNS32*)TPDO_com->pSubindex[1].pObject & 0x7FF);
   59  1        pdo->rtr = NOT_A_REQUEST;
   60  1      
   61  1        MSG_WAR (0x3009, "  PDO CobId is : ",
   62  1                 *(UNS32 *) TPDO_com->pSubindex[1].pObject);
   63  1        MSG_WAR (0x300D, "  Number of objects mapped : ", *pMappingCount);
   64  1      
   65  1        do
   66  1          {
   67  2            UNS8 dataType;            /* Unused */
   68  2            UNS8 tmp[] = { 0, 0, 0, 0, 0, 0, 0, 0 };  /* temporary space to hold bits */
   69  2      
   70  2            /* pointer fo the var which holds the mapping parameter of an mapping entry  */
   71  2            UNS32 *pMappingParameter =
   72  2              (UNS32 *) TPDO_map->pSubindex[prp_j + 1].pObject;
   73  2            UNS16 index = (UNS16) ((*pMappingParameter) >> 16);
   74  2            UNS32 Size = (UNS32) (*pMappingParameter & (UNS32) 0x000000FF);     /* Size in bits */
   75  2      
   76  2            /* get variable only if Size != 0 and Size is lower than remaining bits in the PDO */
   77  2            if (Size && ((offset + Size) <= 64))
   78  2              {
   79  3                UNS32 ByteSize = 1 + ((Size - 1) >> 3);        /*1->8 => 1 ; 9->16 => 2, ... */
   80  3                UNS8 subIndex =
   81  3                  (UNS8) (((*pMappingParameter) >> (UNS8) 8) & (UNS32) 0x000000FF);
   82  3      
   83  3                MSG_WAR (0x300F, "  got mapping parameter : ", *pMappingParameter);
   84  3                MSG_WAR (0x3050, "    at index : ", TPDO_map->index);
   85  3                MSG_WAR (0x3051, "    sub-index : ", prp_j + 1);
   86  3      
   87  3                if (getODentry (d, index, subIndex, tmp, &ByteSize, &dataType, 0) !=
   88  3                    OD_SUCCESSFUL)
   89  3                  {
   90  4                    MSG_ERR (0x1013,
   92  4                             " Couldn't find mapped variable at index-subindex-size : ",
   92  4                             (UNS32) (*pMappingParameter));
   93  4                    return 0xFF;
   94  4                  }
   95  3                /* copy bit per bit in little endian */
   96  3                CopyBits ((UNS8) Size, ((UNS8 *) tmp), 0, 0,
   97  3                          (UNS8 *) & pdo->data[offset >> 3], (UNS8)(offset % 8), 0);
   98  3      
   99  3                offset += Size;
  100  3              }
  101  2            prp_j++;
  102  2          }
  103  1        while (prp_j < *pMappingCount);
  104  1      
  105  1        pdo->len = (UNS8)(1 + ((offset - 1) >> 3));
  106  1      
  107  1        MSG_WAR (0x3015, "  End scan mapped variable", 0);
  108  1      
  109  1        return 0;
  110  1      }
  111         
  112         /*!
  113         **
  114         **
  115         ** @param d
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 3   

  116         ** @param cobId
  117         **
  118         ** @return
  119         **/
  120         UNS8
  121         sendPDOrequest (CO_Data * d, UNS16 RPDOIndex)
  122         {
  123  1        UNS16 *pwCobId;
  124  1        UNS16 offset = d->firstIndex->PDO_RCV;
  125  1        UNS16 lastIndex = d->lastIndex->PDO_RCV;
  126  1      
  127  1        if (!d->CurrentCommunicationState.csPDO)
  128  1          {
  129  2            return 0;
  130  2          }
  131  1      
  132  1        /* Sending the request only if the cobid have been found on the PDO
  133  1           receive */
  134  1        /* part dictionary */
  135  1      
  136  1        MSG_WAR (0x3930, "sendPDOrequest RPDO Index : ", RPDOIndex);
  137  1      
  138  1        if (offset && RPDOIndex >= 0x1400)
  139  1          {
  140  2            offset += RPDOIndex - 0x1400;
  141  2            if (offset <= lastIndex)
  142  2              {
  143  3                /* get the CobId */
  144  3                pwCobId = d->objdict[offset].pSubindex[1].pObject;
  145  3      
  146  3                MSG_WAR (0x3930, "sendPDOrequest cobId is : ", *pwCobId);
  147  3                {
  148  4                  Message pdo;
  149  4                  pdo.cob_id = UNS16_LE(*pwCobId);
  150  4                  pdo.rtr = REQUEST;
  151  4                  pdo.len = 0;
  152  4                  return canSend (d->canHandle, &pdo);
  153  4                }
  154  3              }
  155  2          }
  156  1        MSG_ERR (0x1931, "sendPDOrequest : RPDO Index not found : ", RPDOIndex);
  157  1        return 0xFF;
  158  1      }
  159         
  160         
  161         /*!
  162         **
  163         **
  164         ** @param d
  165         ** @param m
  166         **
  167         ** @return
  168         **/
  169         UNS8
  170         proceedPDO (CO_Data * d, Message * m)
  171         {
  172  1        UNS8 numPdo;
  173  1        UNS8 numMap;                  /* Number of the mapped varable */
  174  1        UNS8 *pMappingCount = NULL;   /* count of mapped objects... */
  175  1        /* pointer to the var which is mapped to a pdo... */
  176  1        /*  void *     pMappedAppObject = NULL;   */
  177  1        /* pointer fo the var which holds the mapping parameter of an
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 4   

  178  1           mapping entry */
  179  1        UNS32 *pMappingParameter = NULL;
  180  1        UNS8 *pTransmissionType = NULL;       /* pointer to the transmission
  181  1                                                 type */
  182  1        UNS16 *pwCobId = NULL;
  183  1        UNS8 Size;
  184  1        UNS8 offset;
  185  1        UNS8 status;
  186  1        UNS32 objDict;
  187  1        UNS16 offsetObjdict;
  188  1        UNS16 lastIndex;
  189  1      
  190  1        status = state2;
  191  1      
  192  1        MSG_WAR (0x3935, "proceedPDO, cobID : ", (UNS16_LE(m->cob_id) & 0x7ff));
  193  1        offset = 0x00;
  194  1        numPdo = 0;
  195  1        numMap = 0;
  196  1        if ((*m).rtr == NOT_A_REQUEST)
  197  1          { 
  198  2            offsetObjdict = d->firstIndex->PDO_RCV;
  199  2            lastIndex = d->lastIndex->PDO_RCV;
  200  2      
  201  2            if (offsetObjdict)
  202  2              while (offsetObjdict <= lastIndex)
  203  2                {
  204  3                  switch (status)
  205  3                    {
  206  4      
  207  4                    case state2:
  208  4                      pwCobId = d->objdict[offsetObjdict].pSubindex[1].pObject;
  209  4                      if (*pwCobId == UNS16_LE(m->cob_id))
  210  4                        {
  211  5                          /* The cobId is recognized */
  212  5                          status = state4;
  213  5                          MSG_WAR (0x3936, "cobId found at index ",
  214  5                                   0x1400 + numPdo);
  215  5                          break;
  216  5                        }
  217  4                      else
  218  4                        {
  219  5                          /* received cobId does not match */
  220  5                          numPdo++;
  221  5                          offsetObjdict++;
  222  5                          status = state2;
  223  5                          break;
  224  5                        }
  225  4      
  226  4                    case state4:     /* Get Mapped Objects Number */
  227  4                      /* The cobId of the message received has been found in the
  228  4                         dictionnary. */
  229  4                      offsetObjdict = d->firstIndex->PDO_RCV_MAP;
  230  4                      lastIndex = d->lastIndex->PDO_RCV_MAP;
  231  4                      pMappingCount =
  232  4                        (UNS8 *) (d->objdict + offsetObjdict +
  233  4                                  numPdo)->pSubindex[0].pObject;
  234  4                      numMap = 0;
  235  4                      while (numMap < *pMappingCount)
  236  4                        {
  237  5                          UNS8 tmp[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
  238  5                          UNS32 ByteSize;
  239  5                          pMappingParameter =
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 5   

  240  5                            (UNS32 *) (d->objdict + offsetObjdict +
  241  5                                       numPdo)->pSubindex[numMap + 1].pObject;
  242  5                          if (pMappingParameter == NULL)
  243  5                            {
  244  6                              MSG_ERR (0x1937, "Couldn't get mapping parameter : ",
  245  6                                       numMap + 1);
  246  6                              return 0xFF;
  247  6                            }
  248  5                          /* Get the addresse of the mapped variable. */
  249  5                          /* detail of *pMappingParameter : */
  250  5                          /* The 16 hight bits contains the index, the medium 8 bits
  251  5                             contains the subindex, */
  252  5                          /* and the lower 8 bits contains the size of the mapped
  253  5                             variable. */
  254  5      
  255  5                          Size = (UNS8) (*pMappingParameter & (UNS32) 0x000000FF);
  256  5      
  257  5                          /* set variable only if Size != 0 and 
  258  5                           * Size is lower than remaining bits in the PDO */
  259  5                          if (Size && ((offset + Size) <= (m->len << 3)))
  260  5                            {
  261  6                              /* copy bit per bit in little endian */
  262  6                              CopyBits (Size, (UNS8 *) & m->data[offset >> 3],
  263  6                                        offset % 8, 0, ((UNS8 *) tmp), 0, 0);
  264  6                              /*1->8 => 1 ; 9->16 =>2, ... */
  265  6                              ByteSize = (UNS32)(1 + ((Size - 1) >> 3));
  266  6      
  267  6                              objDict =
  268  6                                setODentry (d, (UNS16) ((*pMappingParameter) >> 16),
  270  6                                            (UNS8) (((*pMappingParameter) >> 8) &
  270  6                                                    0xFF), tmp, &ByteSize, 0);
  271  6      
  272  6                              if (objDict != OD_SUCCESSFUL)
  273  6                                {
  274  7                                  MSG_ERR (0x1938,
  276  7                                           "error accessing to the mapped var : ",
  276  7                                           numMap + 1);
  277  7                                  MSG_WAR (0x2939, "         Mapped at index : ",
  278  7                                           (*pMappingParameter) >> 16);
  279  7                                  MSG_WAR (0x2940, "                subindex : ",
  280  7                                           ((*pMappingParameter) >> 8) & 0xFF);
  281  7                                  return 0xFF;
  282  7                                }
  283  6      
  284  6                              MSG_WAR (0x3942,
  286  6                                       "Variable updated by PDO cobid : ",
  286  6                                       UNS16_LE(m->cob_id));
  287  6                              MSG_WAR (0x3943, "         Mapped at index : ",
  288  6                                       (*pMappingParameter) >> 16);
  289  6                              MSG_WAR (0x3944, "                subindex : ",
  290  6                                       ((*pMappingParameter) >> 8) & 0xFF);
  291  6                              offset += Size;
  292  6                            }
  293  5                          numMap++;
  294  5                        }             /* end loop while on mapped variables */
  295  4                      if (d->RxPDO_EventTimers)
  296  4                      {
  297  5                          TIMEVAL EventTimerDuration = *(UNS16 *)d->objdict[offsetObjdict].pSubindex[5].pObject;
  298  5                          if(EventTimerDuration){
  299  6                              DelAlarm (d->RxPDO_EventTimers[numPdo]);
  300  6                              d->RxPDO_EventTimers[numPdo] = SetAlarm (d, numPdo, d->RxPDO_EventTimers_Handler,
  301  6                              MS_TO_TIMEVAL (EventTimerDuration), 0);
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 6   

  302  6                          }
  303  5                      }
  304  4                      return 0;
  305  4      
  306  4                    }                 /* end switch status */
  307  3                }                     /* end while */
  308  2          }                           /* end if Donnees //if ((*m).rtr == NOT_A_REQUEST)*/
  309  1        else if ((*m).rtr == REQUEST)
  310  1          {
  311  2            MSG_WAR (0x3946, "Receive a PDO request cobId : ", UNS16_LE(m->cob_id));
  312  2            status = state1;
  313  2            offsetObjdict = d->firstIndex->PDO_TRS;
  314  2            lastIndex = d->lastIndex->PDO_TRS;
  315  2            if (offsetObjdict)
  316  2              while (offsetObjdict <= lastIndex)
  317  2                {
  318  3                  /* study of all PDO stored in the objects dictionary */
  319  3      
  320  3                  switch (status)
  321  3                    {
  322  4      
  323  4                    case state1:     /* check the CobId */
  324  4                      /* get CobId of the dictionary which match to the received PDO
  325  4                       */
  326  4                      pwCobId =
  327  4                         (d->objdict +
  328  4                                   offsetObjdict)->pSubindex[1].pObject;
  329  4                      if (*pwCobId == UNS16_LE(m->cob_id))
  330  4                        {
  331  5                          status = state4;
  332  5                          break;
  333  5                        }
  334  4                      else
  335  4                        {
  336  5                          numPdo++;
  337  5                          offsetObjdict++;
  338  5                        }
  339  4                      status = state1;
  340  4                      break;
  341  4      
  342  4      
  343  4                    case state4:     /* check transmission type */
  344  4                      pTransmissionType =
  345  4                        (UNS8 *) d->objdict[offsetObjdict].pSubindex[2].pObject;
  346  4                      /* If PDO is to be sampled and send on RTR, do it */
  347  4                      if ((*pTransmissionType == TRANS_RTR))
  348  4                        {
  349  5                          status = state5;
  350  5                          break;
  351  5                        }
  352  4                      /* RTR_SYNC means data prepared at SYNC, transmitted on RTR */
  353  4                      else if ((*pTransmissionType == TRANS_RTR_SYNC))
  354  4                        {
  355  5                          if (d->PDO_status[numPdo].
  356  5                              transmit_type_parameter & PDO_RTR_SYNC_READY)
  357  5                            {
  358  6                              /*Data ready, just send */
  359  6                              canSend (d->canHandle,
  360  6                                       &d->PDO_status[numPdo].last_message);
  361  6                              return 0;
  362  6                            }
  363  5                          else
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 7   

  364  5                            {
  365  6                              /* if SYNC did never occur, transmit current data */
  366  6                              /* DS301 do not tell what to do in such a case... */
  367  6                              MSG_ERR (0x1947,
  369  6                                       "Not ready RTR_SYNC TPDO send current data : ",
  369  6                                       UNS16_LE(m->cob_id));
  370  6                              status = state5;
  371  6                            }
  372  5                          break;
  373  5                        }
  374  4                      else if ((*pTransmissionType == TRANS_EVENT_PROFILE) ||
  375  4                               (*pTransmissionType == TRANS_EVENT_SPECIFIC))
  376  4                        {
  377  5                          /* Zap all timers and inhibit flag */
  378  5                          d->PDO_status[numPdo].event_timer =
  379  5                            DelAlarm (d->PDO_status[numPdo].event_timer);
  380  5                          d->PDO_status[numPdo].inhibit_timer =
  381  5                            DelAlarm (d->PDO_status[numPdo].inhibit_timer);
  382  5                          d->PDO_status[numPdo].transmit_type_parameter &=
  383  5                            ~PDO_INHIBITED;
  384  5                          /* Call  PDOEventTimerAlarm for this TPDO, 
  385  5                           * this will trigger emission et reset timers */
  386  5                          PDOEventTimerAlarm (d, numPdo);
  387  5                          return 0;
  388  5                        }
  389  4                      else
  390  4                        {
  391  5                          /* The requested PDO is not to send on request. So, does
  392  5                             nothing. */
  393  5                          MSG_WAR (0x2947, "PDO is not to send on request : ",
  394  5                                   UNS16_LE(m->cob_id));
  395  5                          return 0xFF;
  396  5                        }
  397  4      
  398  4                    case state5:     /* build and send requested PDO */
  399  4                      {
  400  5                        Message pdo;
  401  5                        if (buildPDO (d, numPdo, &pdo))
  402  5                          {
  403  6                            MSG_ERR (0x1948, " Couldn't build TPDO number : ", numPdo);
  404  6                            return 0xFF;
  405  6                          }
  406  5                        canSend (d->canHandle, &pdo);
  407  5                        return 0;
  408  5                      }
  409  4                    }                 /* end switch status */
  410  3                }                     /* end while */
  411  2          }                           /* end if Requete */
  412  1      
  413  1        return 0;
  414  1      }
  415         
  416         /*!
  417         **
  418         **
  419         ** @param NbBits
  420         ** @param SrcByteIndex
  421         ** @param SrcBitIndex
  422         ** @param SrcBigEndian
  423         ** @param DestByteIndex
  424         ** @param DestBitIndex
  425         ** @param DestBigEndian
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 8   

  426         **/
  427         void
  428         CopyBits (UNS8 NbBits, UNS8 * SrcByteIndex, UNS8 SrcBitIndex,
  429                   UNS8 SrcBigEndian, UNS8 * DestByteIndex, UNS8 DestBitIndex,
  430                   UNS8 DestBigEndian)
  431         {
  432  1        /* This loop copy as many bits that it can each time, crossing */
  433  1        /* successively bytes */
  434  1        // boundaries from LSB to MSB.
  435  1        while (NbBits > 0)
  436  1          {
  437  2            /* Bit missalignement between src and dest */
  438  2            INTEGER8 Vect = DestBitIndex - SrcBitIndex;
*** WARNING C192 IN LINE 438 OF CANopen\src\pdo.c: '=': value truncated
  439  2      
  440  2            /* We can now get src and align it to dest */
  441  2            UNS8 Aligned =
  442  2              Vect > 0 ? *SrcByteIndex << Vect : *SrcByteIndex >> -Vect;
  443  2      
  444  2            /* Compute the nb of bit we will be able to copy */
  445  2            UNS8 BoudaryLimit = (Vect > 0 ? 8 - DestBitIndex : 8 - SrcBitIndex);
  446  2            UNS8 BitsToCopy = BoudaryLimit > NbBits ? NbBits : BoudaryLimit;
  447  2      
  448  2            /* Create a mask that will serve in: */
  449  2            UNS8 Mask =
  450  2              ((0xff << (DestBitIndex + BitsToCopy)) |
  451  2               (0xff >> (8 - DestBitIndex)));
*** WARNING C192 IN LINE 451 OF CANopen\src\pdo.c: '=': value truncated
  452  2      
  453  2            /* - Filtering src */
  454  2            UNS8 Filtered = Aligned & ~Mask;
  455  2      
  456  2            /* - and erase bits where we write, preserve where we don't */
  457  2            *DestByteIndex &= Mask;
  458  2      
  459  2            /* Then write. */
  460  2            *DestByteIndex |= Filtered;
  461  2      
  462  2            /*Compute next time cursors for src */
  463  2            if ((SrcBitIndex += BitsToCopy) > 7)      /* cross boundary ? */
  464  2              {
  465  3                SrcBitIndex = 0;      /* First bit */
  466  3                SrcByteIndex += (SrcBigEndian ? -1 : 1);      /* Next byte */
  467  3              }
  468  2      
  469  2      
  470  2            /*Compute next time cursors for dest */
  471  2            if ((DestBitIndex += BitsToCopy) > 7)
  472  2              {
  473  3                DestBitIndex = 0;     /* First bit */
  474  3                DestByteIndex += (DestBigEndian ? -1 : 1);    /* Next byte */
  475  3              }
  476  2      
  477  2            /*And decrement counter. */
  478  2            NbBits -= BitsToCopy;
  479  2          }
  480  1      
  481  1      }
  482         
  483         static void sendPdo(CO_Data * d, UNS32 pdoNum, Message * pdo)
  484         {
  485  1        /*store_as_last_message */
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 9   

  486  1        d->PDO_status[pdoNum].last_message = *pdo;
  487  1        MSG_WAR (0x396D, "sendPDO cobId :", UNS16_LE(pdo->cob_id));
  488  1        MSG_WAR (0x396E, "     Nb octets  : ", pdo->len);
  489  1      
  490  1        canSend (d->canHandle, pdo);
  491  1      }
  492         
  493         
  494         /*!
  495         **
  496         **
  497         ** @param d
  498         **
  499         ** @return
  500         **/
  501         
  502         UNS8
  503         sendPDOevent (CO_Data * d)
  504         {
  505  1        /* Calls _sendPDOevent specifying it is not a sync event */
  506  1        return _sendPDOevent (d, 0);
  507  1      }
  508         
  509         UNS8
  510         sendOnePDOevent (CO_Data * d, UNS8 pdoNum)
  511         {
  512  1        UNS16 offsetObjdict;
  513  1        Message pdo;
  514  1        if (!d->CurrentCommunicationState.csPDO ||
  515  1            (d->PDO_status[pdoNum].transmit_type_parameter & PDO_INHIBITED))
  516  1          {
  517  2            return 0;
  518  2          }
  519  1      
  520  1        offsetObjdict = (UNS16) (d->firstIndex->PDO_TRS + pdoNum);
  521  1      
  522  1        MSG_WAR (0x3968, "  PDO is on EVENT. Trans type : ",
  523  1                 *((UNS8 *) d->objdict[offsetObjdict].pSubindex[2].pObject));
  524  1        
  525  1        memset(&pdo, 0, sizeof(pdo));
  526  1        if (buildPDO (d, pdoNum, &pdo))
  527  1          {
  528  2            MSG_ERR (0x3907, " Couldn't build TPDO number : ",
  529  2                     pdoNum);
  530  2            return 0;
  531  2          }
  532  1      
  533  1        /*Compare new and old PDO */
  534  1        if (d->PDO_status[pdoNum].last_message.cob_id == pdo.cob_id
  535  1            && d->PDO_status[pdoNum].last_message.len == pdo.len
  536  1            && memcmp(d->PDO_status[pdoNum].last_message.data,
  537  1                pdo.data, 8) == 0
  538  1          )
  539  1          {
  540  2            /* No changes -> go to next pdo */
  541  2            return 0;
  542  2          }
  543  1        else
  544  1          {
  545  2      
  546  2            TIMEVAL EventTimerDuration;
  547  2            TIMEVAL InhibitTimerDuration;
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 10  

  548  2      
  549  2            MSG_WAR (0x306A, "Changes TPDO number : ", pdoNum);
  550  2            /* Changes detected -> transmit message */
  551  2            EventTimerDuration =
  552  2              *(UNS16 *) d->objdict[offsetObjdict].pSubindex[5].
  553  2              pObject;
  554  2            InhibitTimerDuration =
  555  2              *(UNS16 *) d->objdict[offsetObjdict].pSubindex[3].
  556  2              pObject;
  557  2      
  558  2            /* Start both event_timer and inhibit_timer */
  559  2            if (EventTimerDuration)
  560  2              {
  561  3                DelAlarm (d->PDO_status[pdoNum].event_timer);
  562  3                d->PDO_status[pdoNum].event_timer =
  563  3                  SetAlarm (d, pdoNum, &PDOEventTimerAlarm,
  564  3                            MS_TO_TIMEVAL (EventTimerDuration), 0);
  565  3              }
  566  2      
  567  2            if (InhibitTimerDuration)
  568  2              {
  569  3                DelAlarm (d->PDO_status[pdoNum].inhibit_timer);
  570  3                d->PDO_status[pdoNum].inhibit_timer =
  571  3                  SetAlarm (d, pdoNum, &PDOInhibitTimerAlarm,
  572  3                            US_TO_TIMEVAL (InhibitTimerDuration *
  573  3                                           100), 0);
  574  3                /* and inhibit TPDO */
  575  3                d->PDO_status[pdoNum].transmit_type_parameter |=
  576  3                  PDO_INHIBITED;
  577  3              }
  578  2      
  579  2            sendPdo(d, pdoNum, &pdo);
  580  2          }
  581  1          return 1;
  582  1      }
  583         
  584         void
  585         PDOEventTimerAlarm (CO_Data * d, UNS32 pdoNum)
  586         {
  587  1        /* This is needed to avoid deletion of re-attribuated timer */
  588  1        d->PDO_status[pdoNum].event_timer = TIMER_NONE;
  589  1        /* force emission of PDO by artificially changing last emitted */
  590  1        d->PDO_status[pdoNum].last_message.cob_id = 0;
  591  1        sendOnePDOevent (d, (UNS8) pdoNum);
  592  1      }
  593         
  594         void
  595         PDOInhibitTimerAlarm (CO_Data * d, UNS32 pdoNum)
  596         {
  597  1        /* This is needed to avoid deletion of re-attribuated timer */
  598  1        d->PDO_status[pdoNum].inhibit_timer = TIMER_NONE;
  599  1        /* Remove inhibit flag */
  600  1        d->PDO_status[pdoNum].transmit_type_parameter &= ~PDO_INHIBITED;
  601  1        sendOnePDOevent (d, (UNS8) pdoNum);
  602  1      }
  603         
  604         void
  605         _RxPDO_EventTimers_Handler(CO_Data *d, UNS32 pdoNum)
  606         {
  607  1      }
*** WARNING C47 IN LINE 605 OF CANopen\src\pdo.c: 'd': unreferenced parameter
*** WARNING C47 IN LINE 605 OF CANopen\src\pdo.c: 'pdoNum': unreferenced parameter
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 11  

  608         
  609         /*!
  610         **
  611         **
  612         ** @param d
  613         ** @param isSyncEvent
  614         **
  615         ** @return
  616         **/
  617         
  618         UNS8
  619         _sendPDOevent (CO_Data * d, UNS8 isSyncEvent)
  620         {
  621  1        UNS8 pdoNum = 0x00;           /* number of the actual processed pdo-nr. */
  622  1        UNS8 *pTransmissionType = NULL;
  623  1        UNS8 status = state3;
  624  1        UNS16 offsetObjdict = d->firstIndex->PDO_TRS;
  625  1        UNS16 offsetObjdictMap = d->firstIndex->PDO_TRS_MAP;
  626  1        UNS16 lastIndex = d->lastIndex->PDO_TRS;
  627  1      
  628  1        if (!d->CurrentCommunicationState.csPDO)
  629  1          {
  630  2            return 0;
  631  2          }
  632  1      
  633  1      
  634  1        /* study all PDO stored in the objects dictionary */
  635  1        if (offsetObjdict)
  636  1          {
  637  2            Message pdo;/* = Message_Initializer;*/
  638  2            memset(&pdo, 0, sizeof(pdo));
  639  2            while (offsetObjdict <= lastIndex)
  640  2              {
  641  3                switch (status)
  642  3                  {
  643  4                  case state3:
  644  4                    if ( /* bSubCount always 5 with objdictedit -> check disabled */
  645  4                         /*d->objdict[offsetObjdict].bSubCount < 5 ||*/
  646  4                         /* check if TPDO is not valid */
  647  4                         *(UNS32 *) d->objdict[offsetObjdict].pSubindex[1].
  648  4                         pObject & 0x80000000)
  649  4                      {
  650  5                        MSG_WAR (0x3960, "Not a valid PDO ", 0x1800 + pdoNum);
  651  5                        /*Go next TPDO */
  652  5                        status = state11;
  653  5                        break;
  654  5                      }
  655  4                    /* get the PDO transmission type */
  656  4                    pTransmissionType =
  657  4                      (UNS8 *) d->objdict[offsetObjdict].pSubindex[2].pObject;
  658  4                    MSG_WAR (0x3962, "Reading PDO at index : ", 0x1800 + pdoNum);
  659  4      
  660  4                    /* check if transmission type is SYNCRONOUS */
  661  4                    /* message transmited every n SYNC with n=TransmissionType */
  662  4                    if (isSyncEvent &&
  663  4                        (*pTransmissionType >= TRANS_SYNC_MIN) &&
  664  4                        (*pTransmissionType <= TRANS_SYNC_MAX) &&
  665  4                        (++d->PDO_status[pdoNum].transmit_type_parameter ==
  666  4                         *pTransmissionType))
  667  4                      {
  668  5                        /*Reset count of SYNC */
  669  5                        d->PDO_status[pdoNum].transmit_type_parameter = 0;
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 12  

  670  5                        MSG_WAR (0x3964, "  PDO is on SYNCHRO. Trans type : ",
  671  5                                 *pTransmissionType);
  672  5                        memset(&pdo, 0, sizeof(pdo));
  673  5                        /*{
  674  5                          Message msg_init = Message_Initializer;
  675  5                          pdo = msg_init;
  676  5                        }*/
  677  5                        if (buildPDO (d, pdoNum, &pdo))
  678  5                          {
  679  6                            MSG_ERR (0x1906, " Couldn't build TPDO number : ",
  680  6                                     pdoNum);
  681  6                            status = state11;
  682  6                            break;
  683  6                          }
  684  5                        status = state5;
  685  5                        /* If transmission RTR, with data sampled on SYNC */
  686  5                      }
  687  4                    else if (isSyncEvent && (*pTransmissionType == TRANS_RTR_SYNC))
  688  4                      {
  689  5                        if (buildPDO
  690  5                            (d, pdoNum, &d->PDO_status[pdoNum].last_message))
  691  5                          {
  692  6                            MSG_ERR (0x1966, " Couldn't build TPDO number : ",
  693  6                                     pdoNum);
  694  6                            d->PDO_status[pdoNum].transmit_type_parameter &=
  695  6                              ~PDO_RTR_SYNC_READY;
  696  6                          }
  697  5                        else
  698  5                          {
  699  6                            d->PDO_status[pdoNum].transmit_type_parameter |=
  700  6                              PDO_RTR_SYNC_READY;
  701  6                          }
  702  5                        status = state11;
  703  5                        break;
  704  5                        /* If transmission on Event and not inhibited, check for changes */
  705  5                      }
  706  4                    else
  707  4                      if ( (isSyncEvent && (*pTransmissionType == TRANS_SYNC_ACYCLIC))
  708  4                           ||
  709  4                           (!isSyncEvent && (*pTransmissionType == TRANS_EVENT_PROFILE || *pTransmissionType == 
             -TRANS_EVENT_SPECIFIC)
  710  4                             && !(d->PDO_status[pdoNum].transmit_type_parameter & PDO_INHIBITED)))
  711  4                      {
  712  5                        sendOnePDOevent(d, pdoNum);
  713  5                        status = state11;
  714  5                      }
  715  4                    else
  716  4                      {
  717  5                        MSG_WAR (0x306C,
  719  5                                 "  PDO is not on EVENT or synchro or not at this SYNC. Trans type : ",
  719  5                                 *pTransmissionType);
  720  5                        status = state11;
  721  5                      }
  722  4                    break;
  723  4                  case state5:       /*Send the pdo */
  724  4                    sendPdo(d, pdoNum, &pdo);
  725  4                    status = state11;
  726  4                    break;
  727  4                  case state11:      /*Go to next TPDO */
  728  4                    pdoNum++;
  729  4                    offsetObjdict++;
  730  4                    offsetObjdictMap++;
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 13  

  731  4                    MSG_WAR (0x3970, "next pdo index : ", pdoNum);
  732  4                    status = state3;
  733  4                    break;
  734  4      
  735  4                  default:
  736  4                    MSG_ERR (0x1972, "Unknown state has been reached :", status);
  737  4                    return 0xFF;
  738  4                  }                   /* end switch case */
  739  3      
  740  3              }                       /* end while */
  741  2          }
  742  1        return 0;
  743  1      }
  744         
  745         /*!
  746         **
  747         **
  748         ** @param d
  749         ** @param OD_entry
  750         ** @param bSubindex
  751         ** @return always 0
  752         **/
  753         
  754         UNS32
  755         TPDO_Communication_Parameter_Callback (CO_Data * d,
  756                                                const indextable * OD_entry,
  757                                                UNS8 bSubindex)
  758         {
  759  1        /* If PDO are actives */
  760  1        if (d->CurrentCommunicationState.csPDO)
  761  1          switch (bSubindex)
  762  1            {
  763  2            case 2:                  /* Changed transmition type */
  764  2            case 3:                  /* Changed inhibit time */
  765  2            case 5:                  /* Changed event time */
  766  2              {
  767  3                const indextable *TPDO_com = d->objdict + d->firstIndex->PDO_TRS;
  768  3                UNS8 numPdo = (UNS8) (OD_entry - TPDO_com);    /* number of the actual processed pdo-nr. */
  769  3      
  770  3                /* Zap all timers and inhibit flag */
  771  3                d->PDO_status[numPdo].event_timer =
  772  3                  DelAlarm (d->PDO_status[numPdo].event_timer);
  773  3                d->PDO_status[numPdo].inhibit_timer =
  774  3                  DelAlarm (d->PDO_status[numPdo].inhibit_timer);
  775  3                d->PDO_status[numPdo].transmit_type_parameter = 0;
  776  3                /* Call  PDOEventTimerAlarm for this TPDO, this will trigger emission et reset timers */
  777  3                PDOEventTimerAlarm (d, numPdo);
  778  3                return 0;
  779  3              }
  780  2      
  781  2            default:                 /* other subindex are ignored */
  782  2              break;
  783  2            }
  784  1        return 0;
  785  1      }
  786         
  787         void
  788         PDOInit (CO_Data * d)
  789         {
  790  1        /* For each TPDO mapping parameters */
  791  1        UNS16 pdoIndex = 0x1800;      /* OD index of TDPO */
  792  1      
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 14  

  793  1        UNS16 offsetObjdict = d->firstIndex->PDO_TRS;
  794  1        UNS16 lastIndex = d->lastIndex->PDO_TRS;
  795  1        if (offsetObjdict)
  796  1          while (offsetObjdict <= lastIndex)
  797  1            {
  798  2              /* Assign callbacks to sensible TPDO mapping subindexes */
  799  2              UNS32 errorCode;
  800  2              ODCallback_t *CallbackList;
  801  2              /* Find callback list */
  802  2              scanIndexOD (d, pdoIndex, &errorCode, &CallbackList);
  803  2              if (errorCode == OD_SUCCESSFUL && CallbackList)
  804  2                {
  805  3                  /*Assign callbacks to corresponding subindex */
  806  3                  /* Transmission type */
  807  3                  CallbackList[2] = &TPDO_Communication_Parameter_Callback;
  808  3                  /* Inhibit time */
  809  3                  CallbackList[3] = &TPDO_Communication_Parameter_Callback;
  810  3                  /* Event timer */
  811  3                  CallbackList[5] = &TPDO_Communication_Parameter_Callback;
  812  3                }
  813  2              pdoIndex++;
  814  2              offsetObjdict++;
  815  2            }
  816  1      
  817  1        /* Trigger a non-sync event */
  818  1        _sendPDOevent (d, 0);
  819  1      }
  820         
  821         void
  822         PDOStop (CO_Data * d)
  823         {
  824  1        /* For each TPDO mapping parameters */
  825  1        UNS8 pdoNum = 0x00;           /* number of the actual processed pdo-nr. */
  826  1        UNS16 offsetObjdict = d->firstIndex->PDO_TRS;
  827  1        UNS16 lastIndex = d->lastIndex->PDO_TRS;
  828  1        if (offsetObjdict)
  829  1          while (offsetObjdict <= lastIndex)
  830  1            {
  831  2              /* Delete TPDO timers */
  832  2              d->PDO_status[pdoNum].event_timer =
  833  2                DelAlarm (d->PDO_status[pdoNum].event_timer);
  834  2              d->PDO_status[pdoNum].inhibit_timer =
  835  2                DelAlarm (d->PDO_status[pdoNum].inhibit_timer);
  836  2              /* Reset transmit type parameter */
  837  2              d->PDO_status[pdoNum].transmit_type_parameter = 0;
  838  2              d->PDO_status[pdoNum].last_message.cob_id = 0;
  839  2              pdoNum++;
  840  2              offsetObjdict++;
  841  2            }
  842  1      }


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        3882     --------
  NEAR-CONST SIZE  =          16     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =    --------     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
C166 COMPILER V7.53.0.0, PDO                                                               09/03/2014 10:38:11 PAGE 15  

  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =    --------     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
