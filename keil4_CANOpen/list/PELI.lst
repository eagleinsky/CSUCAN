C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 1   


C166 COMPILER V7.53.0.0, COMPILATION OF MODULE PELI
OBJECT MODULE PLACED IN .\obj\PELI.obj
COMPILER INVOKED BY: C:\Keil4\C166\BIN\C166.EXE CANopen\drivers\XC164\PELI.c MODV2 BROWSE INCDIR(.\source;.\CANopen\incl
                    -ude;.\CANopen\include\XC164_CANopen;..\keil4;.\CANopen\examples\XC164\Slave) MODV2 DEBUG PRINT(.\list\PELI.lst) TABS(2) 
                    -OBJECT(.\obj\PELI.obj) 

 stmt lvl     source

    1         /*
    2          *********************************************************************************************************
             -***********
    3          *描述：    独立的CAN 控制器SJA1000pelican模式应用函数文件
    4          *文件名:   SJA_PELI.C
    5          *应用语言: KEIL C166
    6          *版本 :    V1.01
    7           ********************************************************************************************************
             -************
    8          */
    9         #define   _SJA_PELICAN_MODE_
   10         #define   _GLOBAL_SJA1000_PELI_APP_
   11         
   12         /*
   13         **********************************************************************************************************
             -**************
   14         **                           导入头文件
   15         **********************************************************************************************************
             -**************
   16         */
   17         #include  "PELI.H"
   18         
   19         /*
   20         **********************************************************************************************************
             -**************
   21         **                           函数原型说明
   22         **********************************************************************************************************
             -**************
   23         */
   24         #include "main.h"
   25         
   26         unsigned short can_select;
   27         unsigned short can_data;
   28         
   29         
   30         uchar ReadSJAReg(uchar address)
   31         {  uchar candata=0;
   32  1      *(can_addr+can_select)=address;
   33  1      candata= *(can_addr+can_data);
   34  1      return candata;
   35  1      }
   36         void WriteSJAReg(uchar address, uchar value )
   37         {
   38  1      *(can_addr+can_select)=address;
   39  1      *(can_addr+can_data)=value;
   40  1      }
   41         void select_chip(uchar ChipNum)
   42         {
   43  1        if (ChipNum == 2)
   44  1        {
   45  2          can_select = SELECT_ADDR2;
   46  2          can_data = DATA_ADDR2;
   47  2        }
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 2   

   48  1        else
   49  1        {
   50  2          can_select = SELECT_ADDR1;
   51  2          can_data = DATA_ADDR1;
   52  2        }
   53  1        //select_chip(ChipMum);
   54  1      }
   55         
   56         /*
   57         **********************************************************************************************************
             -**************
   58         **????:     char   WriteSJARegBlock(unsigned char RegAdr,unsigned char  *ValueBuf,
   59         **                     unsigned char len)
   60         **????:     ValueValueBuf   ?????????????
   61         **        RegAdr      ???sja1000????????
   62         **        len       ???sja1000????????
   63         **???:       SJA_OK       ????
   64         **        !SJA_OK        ?????
   65         **??:         ?????????????sja1000???????
   66         **********************************************************************************************************
             -**************
   67         */
   68         char   WriteSJARegBlock(unsigned char RegAdr,unsigned char  *ValueBuf, unsigned char len)
   69         
   70         {
   71  1        unsigned  char  i;
   72  1          if(len != 0){
   73  2          for(i=0;i<len;i++){
   74  3          //  WriteRawIO(RegAdr+i,ValueBuf+i);
   75  3          //  *(SJA_CS_Point + RegAdr+i) = *(ValueBuf+i);
   76  3            WriteSJAReg(RegAdr+i,*(ValueBuf+i));
   77  3          }
   78  2        }
   79  1        return 0x00;
   80  1      }
   81         
   82         /*
   83         **********************************************************************************************************
             -**************
   84         **????:     char   ReadSJAReg(unsigned char RegAdr,unsigned char  *ValueBuf,
   85         **                     unsigned char len)
   86         **????:     ValueValueBuf   ???????????????
   87         **        RegAdr      ???sja1000????????
   88         **        len       ???sja1000????????
   89         **???:       SJA_OK       ????
   90         **        !SJA_OK        ?????
   91         **??:         ???????sja1000???????
   92         **********************************************************************************************************
             -**************
   93         */
   94         char   ReadSJARegBlock(unsigned char RegAdr,unsigned char  *ValueBuf,
   95                              unsigned char len)
   96         {
   97  1        unsigned  char  i;
   98  1        if(len != 0){
   99  2          for(i=0;i<len;i++){
  100  3            //*(ValueBuf+i)=*(SJA_CS_Point + RegAdr+i);
  101  3            *(ValueBuf+i)=ReadSJAReg(RegAdr+i);
  102  3          }
  103  2        }
  104  1        return 0x00;
  105  1      }
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 3   

  106         /*
  107         **********************************************************************************************************
             -**************
  108         **函数原型:     char   SJATestInterface(unsigned char  testvalue)
  109         **参数说明:     Value  测试值
  110         **返回值:
  111         **              SJA_OK            ; 表示SJA1000接口正常
  112         **              SJA_INTERFACE_ERR ; 表示SJA1000与处理器接口出错
  113         **
  114         **说明:         该函数用于检测CAN控制器的接口是否正常
  115         **********************************************************************************************************
             -**************
  116         */
  117          char    SJATestInterface(unsigned char  testvalue)
  118          {
  119  1              char    status=0;
  120  1        bit   ErrorFlag =1;
  121  1        unsigned char   ErrorCount = 0x20;              //32次报错
  122  1        unsigned char   temp = testvalue;
  123  1        while(--ErrorCount){
  124  2            //WriteSJAReg(REG_CAN_TEST,testvalue);
  125  2          WriteSJAReg(REG_CAN_TEST,temp);
  126  2            if(ReadSJAReg(REG_CAN_TEST) ==  temp){
  127  3            temp =~temp ;
  128  3            WriteSJAReg(REG_CAN_TEST,temp);
  129  3            if(ReadSJAReg(REG_CAN_TEST) ==  temp){
  130  4                  temp =0;
  131  4                        WriteSJAReg(REG_CAN_TEST,temp);
  132  4                  ErrorFlag =0;
  133  4                  break;
  134  4            }
  135  3            else  continue;
  136  3            }
  137  2        }
  138  1          if(ErrorFlag){
  139  2             status  =  SJA_INTERFACE_ERR ;
  140  2      
  141  2          }
  142  1          return (status);
  143  1       }
  144         
  145         /*
  146         **********************************************************************************************************
             -**************
  147         **函数原型:  char   SJAEntryResetMode(void)
  148         **参数说明:  无
  149         **返回值:
  150         **           SJA_OK             ; 表示SJA1000进入复位模式成功
  151         **           SJA_ENTRYRESET_ERR ; 表示SJA1000进入复位模式失败
  152         **
  153         **说明:     该函数用于使sja1000进入复位模式
  154         **********************************************************************************************************
             -**************
  155         */
  156         char   SJAEntryResetMode(void)
  157         {
  158  1          char      status=0;
  159  1          unsigned  char    ErrorFlag =1;
  160  1        unsigned  char  ErrorCount = 0x20;              //32次报错
  161  1        while(--ErrorCount){
  162  2          if((status = SetBitMask(REG_CAN_MOD,RM_RR_BIT)) == 0){
  163  3            ErrorFlag =0;
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 4   

  164  3            break;
  165  3          }
  166  2          }
  167  1        if(ErrorFlag){
  168  2      //       status  = SJA_ENTRYRESET_ERR;
  169  2             status  = 1;
  170  2        }
  171  1          return (status);
  172  1      }
  173         //       basicCan模式   进入复位模式
  174         char   SJAEntryResetMode_BCan(void)
  175         {
  176  1          char      status=0;
  177  1          unsigned  char    ErrorFlag =1;
  178  1        unsigned  char  ErrorCount = 0x20;              //32次报错
  179  1        while(--ErrorCount){
  180  2          if((status = SetBitMask(REG_CR,0x01)) == 0){
  181  3            ErrorFlag =0;
  182  3            break;
  183  3          }
  184  2          }
  185  1        if(ErrorFlag){
  186  2      //       status  = SJA_ENTRYRESET_ERR;
  187  2             status  = 1;
  188  2        }
  189  1          return (status);
  190  1      }
  191         /*
  192         **********************************************************************************************************
             -**************
  193         **函数原型:  char   SJAQuitResetMode(void)
  194         **参数说明:  无
  195         **返回值:
  196         **           SJA_OK             ; 表示SJA1000退出复位模式成功
  197         **           SJA_QUITRESET_ERR  ; 表示SJA1000退出复位模式失败
  198         **
  199         **说明:     该函数用于使sja1000退出复位模式，进入工作模式
  200         **********************************************************************************************************
             -**************
  201         */
  202         char   SJAQuitResetMode(void)
  203         {
  204  1          char      status=0;
  205  1          unsigned  char    ErrorFlag =1;
  206  1        unsigned  char  ErrorCount = 0x20;              //32次报错
  207  1        while(--ErrorCount){
  208  2          if((status=ClearBitMask(REG_CAN_MOD,RM_RR_BIT)) == 0){
  209  3            ErrorFlag =0;
  210  3            break;
  211  3          }
  212  2        }
  213  1        if(ErrorFlag){
  214  2                status  = SJA_QUITRESET_ERR;
  215  2      //            status  = 1；
  216  2        }
  217  1          return (status);
  218  1      }
  219         
  220         char   SJAQuitResetMode_BCan(void)
  221         {
  222  1          char      status=0;
  223  1          unsigned  char    ErrorFlag =1;
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 5   

  224  1        unsigned  char  ErrorCount = 0x20;              //32次报错
  225  1        while(--ErrorCount){
  226  2          if((status=ClearBitMask(REG_CR,0x01)) == 0){
  227  3            ErrorFlag =0;
  228  3            break;
  229  3          }
  230  2        }
  231  1        if(ErrorFlag){
  232  2                status  = SJA_QUITRESET_ERR;
  233  2      //            status  = 1；
  234  2        }
  235  1          return (status);
  236  1      }
  237         
  238         /*
  239         **********************************************************************************************************
             -**************
  240         **函数原型:  char   SJAEntryPeliCANMode(void)
  241         **参数说明:  无
  242         **返回值:
  243         **           SJA_OK         ; 表示SJA1000进入PeliCAN模式 成功
  244         **           SJA_INIT_ERR   ; 表示SJA1000进入PeliCAN模式 失败
  245         **
  246         **说明:     该函数用于使sja1000进入PeliCAN模式
  247         **********************************************************************************************************
             -**************
  248         */
  249         char   SJAEntryPeliCANMode(void)
  250         {
  251  1          char      status=0;
  252  1          if(SJATestRstMode()){                                //处于工作模式
  253  2             status = SJAEntryResetMode();
  254  2          }
  255  1          if(status == 0){                   //处于复位模式
  256  2             status = SetBitMask(REG_CAN_CDR,CANMode_BIT);    //置位sja1000模式控制位
  257  2          }
  258  1          return (status);
  259  1      }
  260         
  261         /*
  262         **********************************************************************************************************
             -**************
  263         **函数原型:  char  SetBitMask(unsigned char RegAdr,unsigned char BitValue)
  264         **参数说明:  RegAdr     要设置位的寄存器地址
  265         **           BitValue   要设置的值
  266         **返回值:
  267         **           SJA_OK(0)      ; 表示设置值 成功
  268         **           SJA_INIT_ERR(1) ; 表示设置值 失败
  269         **
  270         **说明:     该函数用于置位sja1000某寄存器的某位
  271         **********************************************************************************************************
             -**************
  272         */
  273         char  SetBitMask(unsigned char RegAdr,unsigned char BitValue)
  274         {
  275  1          char            status=0;
  276  1          unsigned char   temp;
  277  1          unsigned char   temp1;
  278  1          unsigned char   temp2;
  279  1          temp1 = ReadSJAReg(RegAdr);
  280  1          temp = ReadSJAReg(RegAdr)|BitValue;
  281  1          WriteSJAReg(RegAdr,temp);
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 6   

  282  1          temp2 = ReadSJAReg(RegAdr);
  283  1          if(ReadSJAReg(RegAdr) == temp){
  284  2      //        status  =  SJA_OK;
  285  2              status  =  0;
  286  2          }
  287  1          else{
  288  2      //        status  =  SJA_INIT_ERR ;
  289  2              status  =  1 ;
  290  2          }
  291  1          return (status);
  292  1      }
  293         
  294         /*
  295         **********************************************************************************************************
             -**************
  296         **函数原型:  char  ClearBitMask(unsigned char RegAdr,unsigned char BitValue)
  297         **参数说明:  RegAdr     要清除位的寄存器地址
  298         **           BitValue   要清除的值
  299         **返回值:
  300         **           SJA_OK       ; 表示位清除 成功
  301         **           SJA_INIT_ERR ; 表示位清除 失败
  302         **
  303         **说明:     该函数用于清除sja1000某寄存器的某位
  304         **********************************************************************************************************
             -**************
  305         */
  306         char  ClearBitMask(unsigned char RegAdr,unsigned char BitValue)
  307         {
  308  1          char      status=0;
  309  1          unsigned char   temp;
  310  1          unsigned char   m;
  311  1          temp = ReadSJAReg(RegAdr)&(~BitValue);
  312  1          WriteSJAReg(RegAdr,temp);
  313  1          m = ReadSJAReg(RegAdr);
  314  1          if(ReadSJAReg(RegAdr) == temp){
  315  2          //    status  =  SJA_OK;
  316  2                status  =  0;
  317  2          }
  318  1          else{
  319  2          //    status  =  SJA_INIT_ERR ;
  320  2                status  =  1;
  321  2          }
  322  1          return (status);
  323  1      }
  324         
  325         /*
  326         **********************************************************************************************************
             -**************
  327         **函数原型:  char   SJATestRstMode(void)
  328         **参数说明:  无
  329         **返回值:
  330         **           0   ; 表示SJA1000处于复位模式
  331         **           1   ; 表示SJA1000处于工作模式
  332         **
  333         **说明:     该函数用于测试SJA1000 处于复位模式还是工作模式
  334         **********************************************************************************************************
             -**************
  335         */
  336         char   SJATestRstMode(void)
  337         {
  338  1          char    SjaFlag;
  339  1          if((ReadSJAReg(REG_CAN_MOD)&RM_RR_BIT) ==  RM_RR_BIT){
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 7   

  340  2              SjaFlag  =  0;
  341  2          }
  342  1          else{
  343  2              SjaFlag  = 1 ;
  344  2          }
  345  1          return (SjaFlag);
  346  1      }
  347         
  348         /*
  349         **********************************************************************************************************
             -**************
  350         **函数原型:  char   SJASetOutControl(unsigned char  OutCtrl)
  351         **参数说明:  OutCtrl  输出控制寄存器的设定值
  352         **返回值:
  353         **           0            ; 设置输出控制寄存器成功
  354         **       SJA_SETOCR_ERR   ; 设置输出控制寄存器错
  355         **       SJA_NOTRSTMODE     ; sja1000不在复位模式
  356         **
  357         **说明:     该函数用于设定sja1000的输出控制
  358         **********************************************************************************************************
             -**************
  359         */
  360         char    SJASetOutControl(unsigned char  OutCtrl)
  361         {
  362  1        char      status=0;
  363  1        bit     ErrorFlag=1;
  364  1        unsigned  char  ErrorCount =0x20;       //32次，报错
  365  1        if(SJATestRstMode()){                                //处于工作模式
  366  2          status = SJA_NOTRSTMODE;
  367  2        }
  368  1        else{
  369  2          while(--ErrorCount){
  370  3            WriteSJAReg(REG_CAN_OCR,OutCtrl);
  371  3            if(ReadSJAReg(REG_CAN_OCR) == OutCtrl){
  372  4              ErrorFlag=0;
  373  4              break;
  374  4            }
  375  3          }
  376  2          if(ErrorFlag){
  377  3            status = SJA_SETOCR_ERR;
  378  3          }
  379  2        }
  380  1        return  status;
  381  1      }
  382         
  383         /*
  384         **********************************************************************************************************
             -**************
  385         **函数原型:  char   SJASetClockDivision(unsigned  char  clockdiv)
  386         **参数说明:  clockdiv 时钟分频寄存器的设定值
  387         **返回值:
  388         **           0            ; 设置时钟分频寄存器成功
  389         **       SJA_SETCDR_ERR   ; 设置时钟分频寄存器错
  390         **       SJA_NOTRSTMODE     ; sja1000不在复位模式
  391         **
  392         **说明:     该函数用于设定sja1000的时钟分频寄存器
  393         **********************************************************************************************************
             -**************
  394         */
  395         char    SJASetClockDivision(unsigned  char  clockdiv)
  396         {
  397  1        char    status=0,temp = 0, temp1 = 0;
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 8   

  398  1        bit     ErrorFlag=1;
  399  1        unsigned  char  ErrorCount =0x20;       //32次，报错
  400  1        if(SJATestRstMode()){                                //处于工作模式
  401  2          status = SJA_NOTRSTMODE;
  402  2        }
  403  1        else{
  404  2          while(--ErrorCount){
  405  3            temp1 = ReadSJAReg(REG_CAN_CDR);
  406  3            temp = (temp1 & 0xf0) | (clockdiv & 0x0f);
  407  3            WriteSJAReg(REG_CAN_CDR,temp);
  408  3            if((ReadSJAReg(REG_CAN_CDR) & 0x0f) == clockdiv){
  409  4              ErrorFlag=0;
  410  4              break;
  411  4            }
  412  3          }
  413  2          if(ErrorFlag){
  414  3            status = SJA_SETCDR_ERR;
  415  3          }
  416  2        }
  417  1        return  status;
  418  1      }
  419         
  420         /*
  421         **********************************************************************************************************
             -**************
  422         **函数原型:  char SJASetAccCode(unsigned char acr0,unsigned char acr1,
  423         **                unsigned char acr2,unsigned char acr3
  424         **                )
  425         **参数说明:  acr0 代码验收寄存器0的设定值
  426         **       acr1 代码验收寄存器1的设定值
  427         **       acr2 代码验收寄存器2的设定值
  428         **       acr3 代码验收寄存器3的设定值
  429         **返回值:
  430         **           0              ; 设置代码验收寄存器成功
  431         **       SJA_SETACR_ERR   ; 设置代码验收寄存器错
  432         **       SJA_NOTRSTMODE       ; sja1000不在复位模式
  433         **
  434         **说明:     该函数用于设定报文滤波的代码验收滤波器
  435         **********************************************************************************************************
             -**************
  436         */
  437         char  SJASetAccCode(unsigned char acr0,unsigned char acr1,
  438                   unsigned char acr2,unsigned char acr3
  439                   )
  440         {
  441  1        char    status=0;
  442  1        bit     ErrorFlag=1;
  443  1        unsigned  char    ErrorCount =0x20;       //32次，报错
  444  1        if(SJATestRstMode()){                                //处于工作模式
  445  2          status = SJA_NOTRSTMODE;
  446  2        }
  447  1        else{
  448  2          while(--ErrorCount){
  449  3            WriteSJAReg(REG_CAN_ACR0,acr0);
  450  3            WriteSJAReg(REG_CAN_ACR1,acr1);
  451  3            WriteSJAReg(REG_CAN_ACR2,acr2);
  452  3            WriteSJAReg(REG_CAN_ACR3,acr3);
  453  3            if(ReadSJAReg(REG_CAN_ACR0) != acr0)continue;
  454  3            if(ReadSJAReg(REG_CAN_ACR1) != acr1)continue;
  455  3            if(ReadSJAReg(REG_CAN_ACR2) != acr2)continue;
  456  3            if(ReadSJAReg(REG_CAN_ACR3) != acr3)continue;
  457  3            ErrorFlag=0;
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 9   

  458  3            break;
  459  3          }
  460  2          if(ErrorFlag){
  461  3            status =SJA_SETACR_ERR;
  462  3          }
  463  2        }
  464  1          return  status;
  465  1        
  466  1      }
  467         
  468         /*
  469         **********************************************************************************************************
             -**************
  470         **函数原型:  char SJASetAccMask(unsigned char amr0,unsigned char amr1,
  471         **                    unsigned char amr2,unsigned char amr3
  472         **                    )
  473         **参数说明:  amr0 验收屏蔽寄存器0的设定值
  474         **       amr1 验收屏蔽寄存器1的设定值
  475         **       amr2 验收屏蔽寄存器2的设定值
  476         **       amr3 验收屏蔽寄存器3的设定值
  477         **返回值:
  478         **           0            ; 设置验收屏蔽寄存器成功
  479         **       SJA_SETAMR_ERR   ; 设置验收屏蔽寄存器错
  480         **       SJA_NOTRSTMODE     ; sja1000不在复位模式
  481         **
  482         **说明:     该函数用于设定报文滤波的验收屏蔽寄存器
  483         **********************************************************************************************************
             -**************
  484         */
  485         char  SJASetAccMask(unsigned char amr0,unsigned char amr1,
  486                       unsigned char amr2,unsigned char amr3
  487                       )
  488         {
  489  1        char    status=0;
  490  1        bit     ErrorFlag=1;
  491  1        unsigned  char    ErrorCount =0x20;       //32次，报错
  492  1        if(SJATestRstMode()){                                //处于工作模式
  493  2          status = SJA_NOTRSTMODE;
  494  2        }
  495  1        else{
  496  2          while(--ErrorCount){
  497  3            WriteSJAReg(REG_CAN_AMR0,amr0);
  498  3            WriteSJAReg(REG_CAN_AMR1,amr1);
  499  3            WriteSJAReg(REG_CAN_AMR2,amr2);
  500  3            WriteSJAReg(REG_CAN_AMR3,amr3);
  501  3            if(ReadSJAReg(REG_CAN_AMR0) != amr0)continue;
  502  3            if(ReadSJAReg(REG_CAN_AMR1) != amr1)continue;
  503  3            if(ReadSJAReg(REG_CAN_AMR2) != amr2)continue;
  504  3            if(ReadSJAReg(REG_CAN_AMR3) != amr3)continue;
  505  3            ErrorFlag=0;
  506  3            break;
  507  3          }
  508  2          if(ErrorFlag){
  509  3            status =SJA_SETAMR_ERR;
  510  3          }
  511  2        }
  512  1          return  status;
  513  1      }
  514         /*
  515         **********************************************************************************************************
             -**************
  516         **函数原型:  char SJASetBandRateStandard(unsigned char  BandRateSize)
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 10  

  517         **参数说明:  BandRateSize     标准常用波特率(Kbps)
  518         **        0         5
  519         **        1         10
  520         **        2         20
  521         **        3         40
  522         **        4         50
  523         **        5         80
  524         **        6         100
  525         **        7         125
  526         **        8         200
  527         **        9         250
  528         **        10          400
  529         **        11          500
  530         **        12          666
  531         **        13          800
  532         **        14          1000
  533         **返回值:
  534         **           0            ; 设置总线定时器成功
  535         **       SJA_SETBTR_ERR     ; 设置总线定时器错
  536         **       SJA_NOBTRSIZE      ;波特率不能设为此值
  537         **
  538         **说明:     该函数用于设定在系统晶体为16MHZ时，常用的标准波特率的值。
  539         **      参数BandRateSize只能为0~12，其它的值会返回SJA_NOBTRSIZE错误
  540         **      本函数只能用于复位模式
  541         **********************************************************************************************************
             -**************
  542         */
  543         unsigned  char  SJA_BTR_CODETAB[]={
  544             0xbf,0xff,            //;5KBPS的预设值
  545             0x67,0x2f,            //;10KBPS的预设值
  546             0x53,0x2F,                   //;20KBPS的预设值
  547             0x87,0xFF,                     //;40KBPS的预设值
  548             0x47,0x2F,                     //;50KBPS的预设值
  549             0x83,0xFF,                     //;80KBPS的预设值
  550             0x43,0x2f,                     //;100KBPS的预设值
  551             0x03,0x1c,                     //;125KBPS的预设值
  552             0x81,0xfa,                     //;200KBPS的预设值
  553             0x01,0x1c,                     //;250KBPS的预设值
  554             0x80,0xfa,                     //;400KBPS的预设值
  555             0x00,0x1c,                     //;500KBPS的预设值
  556             0x80,0xb6,                     //;666KBPS的预设值
  557             0x00,0x16,                     //;800KBPS的预设值
  558             0x00,0x14                      //;1000KBPS的预设值
  559           };
  560         char  SJASetBandRateStandard(unsigned char  BandRateSize)
  561         {
  562  1        char  status=0;
  563  1        bit   ErrorFlag =1;
  564  1        unsigned  char  ErrorCount = 0x20;        //32次报错
  565  1        if(BandRateSize>14){
  566  2          status = SJA_NOBTRSIZE;
  567  2        }
  568  1          else{
  569  2          while(--ErrorCount){
  570  3              WriteSJAReg(REG_CAN_BTR0,SJA_BTR_CODETAB[BandRateSize*2]);
  571  3              WriteSJAReg(REG_CAN_BTR1,SJA_BTR_CODETAB[BandRateSize*2+1]);
  572  3              if(ReadSJAReg(REG_CAN_BTR0) != SJA_BTR_CODETAB[BandRateSize*2])continue;
  573  3              if(ReadSJAReg(REG_CAN_BTR1) != SJA_BTR_CODETAB[BandRateSize*2+1])continue;
  574  3              ErrorFlag=0;
  575  3              break;
  576  3      
  577  3          }//while结束
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 11  

  578  2          if(ErrorFlag){
  579  3            status =SJA_SETBTR_ERR;
  580  3          }
  581  2        }
  582  1        return  status;
  583  1      }
  584         
  585         /*
  586         **********************************************************************************************************
             -**************
  587         **函数原型:  char SJASystemPrgCMD(unsigned char cmd)
  588         **参数说明:  cmd  SJA1000 的PeliCAN 工作方式命令字
  589         **返回值:
  590         **           0          ; 表示命令执行成功
  591         **       SJA_IMPCMD_ERR   ; 表示命令执行出错
  592         **       SJA_NOTHISCMD    ; 没有此命令
  593         **
  594         **说明:     该函数用于执行sja1000的命令
  595         **********************************************************************************************************
             -**************
  596         */
  597         char  SJASystemPrgCMD(unsigned char cmd)
  598         {
  599  1        char  status=0;
  600  1      
  601  1        switch(cmd){
  602  2          case  0x01:
  603  2          case  0x03:
  604  2                WriteSJAReg(REG_CAN_CMR,cmd);
  605  2              break;
  606  2          case  0x02:
  607  2              if((ReadSJAReg(REG_CAN_SR)&TBS_BIT) == 0){
  608  3                status =  SJA_IMPCMD_ERR;
  609  3              }
  610  2              break;
  611  2          case  0x04:
  612  2              WriteSJAReg(REG_CAN_CMR,cmd);
  613  2              break;
  614  2          case  0x08:
  615  2              WriteSJAReg(REG_CAN_CMR,cmd);
  616  2              break;
  617  2          case  0x10:
  618  2          case  0x12:
  619  2                WriteSJAReg(REG_CAN_CMR,cmd);
  620  2              break;
  621  2          default:
  622  2              status = SJA_NOTHISCMD;
  623  2              break;
  624  2        }
  625  1          return    status;
  626  1      
  627  1      }
  628         
  629         
  630         
  631         
  632         /*
  633         **********************************************************************************************************
             -**************
  634         **函数原型:  char SJASendData(unsigned  char      *databuf,
  635         **                  unsigned  char  cmd
  636         **                  )
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 12  

  637         **参数说明:  databuf  存放要发送到总线的特定帧格式的数据的缓冲区首地址
  638         **       cmd    sj1000发送命令
  639         **返回值:
  640         **           0          ; 表示将数据成功的发送到can总线
  641         **       SJA_TXBUFLOCK    ; sja1000发送缓冲区锁定
  642         **           SJA_WTXBUF_ERR   ; 表示写发送缓冲区失败
  643         **       SJA_IMPCMD_ERR   ; 表示命令执行出错
  644         **
  645         **说明：  本函数用于向can总线发送数据
  646         **********************************************************************************************************
             -**************
  647         */
  648         char  SJASendData(unsigned  char  port,
  649                           unsigned  char  *databuf,
  650                           unsigned  char  cmd
  651                          )
  652         {
  653  1        char  status=0;
  654  1        unsigned  char  len;
  655  1        unsigned  char  temp = (*databuf&0x0f);
  656  1        if(temp>8)temp=8;
  657  1        
  658  1         select_chip(port);
  659  1      
  660  1        if( (ReadSJAReg(REG_CAN_SR)&TCS_BIT) ==0){//sja1000发送缓冲区锁定
  661  2          status =  SJA_TXBUFLOCK;
  662  2        }
  663  1        else if( (ReadSJAReg(REG_CAN_SR)&RS_BIT) !=0){//正在接收
  664  2          status =  SJA_WTXBUF_ERR;
  665  2        }
  666  1      
  667  1        else{
  668  2          switch(*databuf&0xC0) {
  669  3            case  0x00://标准帧、数据帧
  670  3                len = (unsigned char)(STD_FRAMEID_LENTH+temp+1);
  671  3                WriteSJARegBlock(REG_CAN_TXFMINFO,databuf,len);
  672  3                status=SJASystemPrgCMD(cmd);
  673  3                break;
  674  3            case  0x40://标准帧、远程帧
  675  3                len=STD_FRAMEID_LENTH+1;
  676  3                WriteSJARegBlock(REG_CAN_TXFMINFO,databuf,len);
  677  3                status=SJASystemPrgCMD(cmd);
  678  3                break;
  679  3            case  0x80://扩展帧、数据帧
  680  3                len=(unsigned char)(EXT_FRAMEID_LENTH+temp+1);
  681  3                WriteSJARegBlock(REG_CAN_TXFMINFO,databuf,len);
  682  3                status=SJASystemPrgCMD(cmd);
  683  3                break;
  684  3            case  0xC0://扩展帧、远程帧
  685  3                len=EXT_FRAMEID_LENTH+1;
  686  3                WriteSJARegBlock(REG_CAN_TXFMINFO,databuf,len);
  687  3                status=SJASystemPrgCMD(cmd);
  688  3                break;
  689  3            default:status = SJA_WTXBUF_ERR;
  690  3                break;
  691  3          }
  692  2        }
  693  1      
  694  1        return  status;
  695  1      }
  696         /*
  697         **********************************************************************************************************
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 13  

             -**************
  698         **函数原型:  char SJARcvData(unsigned char      *databuf)
  699         **参数说明:  databuf  存放要接收数据缓冲区首地址
  700         **
  701         **返回值:
  702         **           0          ; 表示将读取数据成功
  703         **       SJA_RXBUFEMPTY   ; sja1000接收缓冲区为空
  704         **           SJA_RRXVUF_ERR   ; sja1000接收数据错
  705         **
  706         **说明：  本函数用于接收can总线数据
  707         **********************************************************************************************************
             -**************
  708         */
  709         char  SJARcvData(unsigned char  port,unsigned char      *databuf)
  710         {
  711  1        char  status=0;
  712  1        unsigned  char  len;
  713  1        unsigned  char  temp;
  714  1        
  715  1        select_chip(port);
  716  1        
  717  1        *databuf= ReadSJAReg(REG_CAN_RXFMINFO);
  718  1        temp = (*databuf&0x0f);
  719  1        if(temp>8)temp=8;
  720  1      
  721  1        if( (ReadSJAReg(REG_CAN_SR)&RBS_BIT ) ==0){//sja1000接收缓冲区为空
  722  2          status =  SJA_RXBUFEMPTY  ;
  723  2        }
  724  1      
  725  1        else{
  726  2          switch(*databuf&0xC0) {
  727  3            case  0x00://标准帧、数据帧
  728  3                len=STD_FRAMEID_LENTH+temp;
  729  3                ReadSJARegBlock(REG_CAN_RXBUF1,databuf+1,len);
  730  3                status= SJASystemPrgCMD(RELEASE_RX_BUF);
  731  3                break;
  732  3            case  0x40://标准帧、远程帧
  733  3      
  734  3                ReadSJARegBlock(REG_CAN_RXBUF1,databuf+1,STD_FRAMEID_LENTH);
  735  3                status= SJASystemPrgCMD(RELEASE_RX_BUF);
  736  3                break;
  737  3            case  0x80://扩展帧、数据帧
  738  3                len=EXT_FRAMEID_LENTH+temp;
  739  3                ReadSJARegBlock(REG_CAN_RXBUF1,databuf+1,len);
  740  3                status=SJASystemPrgCMD(RELEASE_RX_BUF);
  741  3                break;
  742  3            case  0xC0://扩展帧、远程帧
  743  3      
  744  3                ReadSJARegBlock(REG_CAN_RXBUF1,databuf+1,EXT_FRAMEID_LENTH);
  745  3                status= SJASystemPrgCMD(RELEASE_RX_BUF);
  746  3                break;
  747  3            default:status = SJA_RRXVUF_ERR;
  748  3                break;
  749  3          }
  750  2        }
  751  1        return  status;
  752  1      }
  753         
  754         /*
  755         **********************************************************************************************************
             -**************
  756         **函数原型:     unsigned  char  ReadALCReg(void)
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 14  

  757         **参数说明:     无
  758         **返回值:   错误仲裁寄存器(alc)的内容
  759         **
  760         **说明:         该函数用于读取错误仲裁寄存器(alc)的内容
  761         **********************************************************************************************************
             -**************
  762         */
  763         unsigned  char  ReadALCReg(void)
  764         {
  765  1        return(ReadSJAReg(REG_CAN_ALC));
  766  1      }
  767         
  768         /*
  769         **********************************************************************************************************
             -**************
  770         **函数原型:     unsigned  char  ReadECCReg(void)
  771         **参数说明:     无
  772         **返回值:   错误捕捉寄存器(ecc)的内容
  773         **
  774         **说明:         该函数用于读取错误捕捉寄存器(ecc)的内容
  775         **********************************************************************************************************
             -**************
  776         */
  777         unsigned  char  ReadECCReg(void)
  778         {
  779  1        return(ReadSJAReg(REG_CAN_ECC));
  780  1      }
  781         
  782         /*
  783         **********************************************************************************************************
             -**************
  784         **函数原型:     void  SJA1000_Config(SJAConfigStruct ChipConfig)
  785         **参数说明:     
  786         **返回值:   
  787         **
  788         **说明:         SJA1000配置信息
  789         **********************************************************************************************************
             -**************
  790         */
  791         void  SJA1000_Config(SJAConfigStruct ChipConfig)
  792         {
  793  1        unsigned char ACR[4];
  794  1        unsigned char AMR[4];
  795  1        
  796  1       select_chip(ChipConfig.ChipNum);  //选择芯片
  797  1       SJAEntryResetMode();   //进入复位模式
  798  1       SJAEntryPeliCANMode(); //选择peliCAN模式
  799  1       SJASetClockDivision(8); //时钟关闭
  800  1        
  801  1       if(!ChipConfig.ExtendedFrame) //如果是标准帧
  802  1         {ACR[0] = (unsigned char)((ChipConfig.ACR >> 3) & 0xff); //高八位
  803  2          ACR[1] = (unsigned char)((ChipConfig.ACR << 5) & 0xE0); //低三位
  804  2          ACR[2] = 0; 
  805  2          ACR[3] = 0;
  806  2          SJASetAccCode(ACR[0],ACR[1],ACR[2],ACR[3]);
  807  2          AMR[0] = (unsigned char)((ChipConfig.AMR >> 3) & 0xff); //高八位
  808  2          AMR[1] = (unsigned char)((ChipConfig.AMR << 5) & 0xE0); //低三位
  809  2          AMR[2] = 0xff; 
  810  2          AMR[3] = 0xff;
  811  2          SJASetAccMask(AMR[0],AMR[1]|0x0F,AMR[2],AMR[3]); 
  812  2         }
  813  1       else                         //如果是扩展帧
C166 COMPILER V7.53.0.0, PELI                                                              09/03/2014 17:57:05 PAGE 15  

  814  1         {
  815  2          ACR[0] = (unsigned char)((ChipConfig.ACR >> 21) & 0xFF); //ID.28-ID.21
  816  2          ACR[1] = (unsigned char)((ChipConfig.ACR >> 13) & 0xFF); //ID.20-ID.13
  817  2          ACR[2] = (unsigned char)((ChipConfig.ACR >>  5) & 0xFF); //ID.12-ID.5
  818  2          ACR[3] = (unsigned char)((ChipConfig.ACR <<  3) & 0xF8); //ID.4 -ID.0
  819  2          SJASetAccCode(ACR[0],ACR[1],ACR[2],ACR[3]);
  820  2          AMR[0] = (unsigned char)((ChipConfig.AMR >> 21) & 0xFF); //ID.28-ID.21
  821  2          AMR[1] = (unsigned char)((ChipConfig.AMR >> 13) & 0xFF); //ID.20-ID.13
  822  2          AMR[2] = (unsigned char)((ChipConfig.AMR >>  5) & 0xFF); //ID.12-ID.5
  823  2          AMR[3] = (unsigned char)((ChipConfig.AMR <<  3) & 0xF8); //ID.4 -ID.0
  824  2          SJASetAccMask(AMR[0],AMR[1],AMR[2],AMR[3]|0x03); 
  825  2         }
  826  1        SJASetBandRateStandard(ChipConfig.BaudRate);  //波特率
  827  1        SJASetOutControl(Tx1Float|Tx0PshPull|NormalMode); //OCR，输出控制寄存器；TX1悬空，TX0推挽；正常输出模式
  828  1      
  829  1        WriteSJAReg(REG_CAN_IER,0x01);  /////使能SJA1000接收中断
  830  1        SJAQuitResetMode();
  831  1        WriteSJAReg(REG_CAN_MOD,0x08);
  832  1      }
  833           


MODULE INFORMATION:   INITIALIZED  UNINITIALIZED
  CODE SIZE        =        2296     --------
  NEAR-CONST SIZE  =    --------     --------
  FAR-CONST SIZE   =    --------     --------
  HUGE-CONST SIZE  =    --------     --------
  XHUGE-CONST SIZE =    --------     --------
  NEAR-DATA SIZE   =          34     --------
  FAR-DATA SIZE    =    --------     --------
  XHUGE-DATA SIZE  =    --------     --------
  IDATA-DATA SIZE  =    --------     --------
  SDATA-DATA SIZE  =    --------     --------
  BDATA-DATA SIZE  =    --------     --------
  HUGE-DATA SIZE   =    --------     --------
  BIT SIZE         =    --------     --------
  INIT'L SIZE      =          34     --------
END OF MODULE INFORMATION.


C166 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
